package iEscort;

uses Set,
     Sim,
     Group,
     Math,
     List,
     Object,
     MapEnumerations,
     iMapEntity,
     String,
     iFaction,
     iSim,
     iBody,
     iHabitat,
     iShip,
     Subsim,
     iDockport,
     iLagrangePoint,
     iAI,
     INIFile,
     iUtilities;

provides V,
         Wedge,
         LineAbreast,
         LineAhead,
         Parade,
         SkirmishLine,
         Cross,
         Loose,
         Impi,
         Outrider,
         Goose,
         LineAstern,
         Box,
         Claw,
         Wall,
         RandomRectangle,
         RandomSphere,
         Stack,
         LockGroupsInFormation,
         InFormationImpi,
         InFormationGoose,
         InFormationV,
         InFormationClaw,
         InFormationSkirmishLine;

prototype local_function_0( hgroup group_, float param_1_, float param_2_, bool param_3_, bool param_4_ );
prototype V( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Goose( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Wedge( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype LineAbreast( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype LineAhead( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Parade( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype SkirmishLine( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Cross( hgroup ship_list_, float offset_, float radius_, bool first_time_ );
prototype Loose( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Impi( hgroup ship_list_, float offset_, float radius_, bool first_time_ );
prototype Outrider( hgroup ship_list_, float offset_, float radius_, bool first_time_ );
prototype LineAstern( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Box( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Claw( hgroup ship_list_, float offset_, float radius_, bool first_time_ );
prototype Wall( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype RandomRectangle( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype RandomSphere( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype Stack( hgroup group_, float spacing_offset_, float radius_, bool first_time_ );
prototype LockGroupsInFormation( hgroup lead_group_, hobject secondary_group_, float x_, float y_, float z_, float radius_, bool first_time_ );
prototype InFormationImpi( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ );
prototype local_function_1( hgroup group_, hobject param_1_, int param_2_, float param_3_, float param_4_, float param_5_, float param_6_, float param_7_, bool param_8_, bool param_9_ );
prototype InFormationV( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ );
prototype InFormationGoose( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ );
prototype InFormationClaw( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float offset_, float radius_, bool first_time_ );
prototype InFormationSkirmishLine( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_offset_, float radius_, bool first_time_ );

local_function_0( hgroup group_, float param_1_, float param_2_, bool param_3_, bool param_4_ )
{
	int simCount;
	int ii;
	bool local_2 = true;
	float local_3;
	int local_4;
	float local_5 = 0.0;
	float local_6 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_3 = iUtilities.GetLargestShipRadius( group_ );
	local_3 = ( (local_3 * 2.0) + param_1_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_2 == 1 )
			{
				if ( local_5 < 0.0 )
				{
					local_5 = -local_5;
				}
				
				local_5 = ( local_5 + local_3 );
				local_2 = false;
				
				if ( param_4_ )
				{
					local_6 = ( local_6 - local_3 );
				}
				else
				{
					local_6 = ( local_6 + local_3 );
				}
			}
			else
			{
				local_5 = -local_5;
				local_2 = true;
			}
			
			if ( param_3_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_5, 0.0, local_6 );
				
				if ( Group.NthSim( group_, ii ) )
				{
					ship = iShip.Cast( Group.NthSim( group_, ii ) );
					iAI.GiveEscortOrder( ship, groupIter_1, local_5, 0.0, local_6, param_2_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_5, 0.0, local_6, param_2_ );
			}
		}
	}
}

V( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	bool local_0 = false;
	
	local_function_0( group_, spacing_offset_, radius_, first_time_, local_0 );
}

Goose( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	bool local_0 = true;
	
	local_function_0( group_, spacing_offset_, radius_, first_time_, local_0 );
}

Wedge( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii = 0;
	int local_2 = 0;
	bool local_3 = true;
	int local_4 = 3;
	float local_5 = 0.0;
	float local_6;
	float local_7 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_5 = iUtilities.GetLargestShipRadius( group_ );
	local_5 = ( (local_5 * 2.0) + spacing_offset_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_2 == 0 )
			{
				local_7 = ( local_7 - local_5 );
				local_6 = 0.0;
				local_2 = ( local_2 + 1 );
			}
			else if ( local_3 == 1 )
			{
				if ( local_6 < 0.0 )
				{
					local_6 = -local_6;
				}
				
				local_6 = ( local_6 + local_5 );
				local_3 = false;
				local_2 = ( local_2 + 1 );
			}
			else
			{
				local_6 = -local_6;
				local_3 = true;
				local_2 = ( local_2 + 1 );
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_6, 0.0, local_7 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					ship = iShip.Cast( groupIter_0 );
					iAI.GiveEscortOrder( ship, groupIter_1, local_6, 0.0, local_7, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_6, 0.0, local_7, radius_ );
			}
			
			if ( local_2 == local_4 )
			{
				local_4 = ( local_4 + 2 );
				local_2 = 0;
			}
		}
	}
}

LineAbreast( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	bool local_2 = true;
	float local_3;
	int local_4;
	float local_5 = 0.0;
	hsim groupIter;
	hsim local_7;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_3 = iUtilities.GetLargestShipRadius( group_ );
	local_3 = ( (local_3 * 2.0) + spacing_offset_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			local_7 = Sim.Cast( Group.NthSim( group_, ii ) );
		}
		else
		{
			groupIter = Group.NthSim( group_, ii );
			
			if ( local_2 == 1 )
			{
				if ( local_5 < 0.0 )
				{
					local_5 = -local_5;
				}
				
				local_5 = ( local_5 + local_3 );
				local_2 = false;
			}
			else
			{
				local_5 = -local_5;
				local_2 = true;
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter, local_7, local_5, 0.0, 0.0 );
				
				if ( iShip.Cast( groupIter ) )
				{
					ship = iShip.Cast( groupIter );
					iAI.GiveEscortOrder( ship, local_7, local_5, 0.0, 0.0, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, local_7, local_5, 0.0, 0.0, radius_ );
			}
		}
	}
}

LineAhead( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	float local_2;
	int local_3;
	float local_4 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_2 = iUtilities.GetLargestShipRadius( group_ );
	local_2 = ( (local_2 * 2.0) + spacing_offset_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			local_4 = ( local_4 - local_2 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, 0.0, 0.0, local_4 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					ship = iShip.Cast( groupIter_0 );
					iAI.GiveEscortOrder( ship, groupIter_1, 0.0, 0.0, local_4, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, 0.0, 0.0, local_4, radius_ );
			}
		}
	}
}

Parade( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int local_1;
	int local_2;
	int ii;
	int local_4;
	int local_5 = 0;
	float local_6;
	float local_7;
	float local_8 = 0.0;
	float local_9 = 0.0;
	float local_10 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_10 = iUtilities.GetLargestShipRadius( group_ );
	local_10 = ( (local_10 * 2.0) + spacing_offset_ );
	local_6 = simCount;
	local_7 = Math.Sqrt( local_6 );
	local_1 = local_7;
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
			local_5 = ( local_5 + 1 );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_5 == local_1 )
			{
				local_8 = 0.0;
				local_9 = ( local_9 - local_10 );
				local_5 = 1;
			}
			else
			{
				local_8 = ( local_8 + local_10 );
				local_5 = ( local_5 + 1 );
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_8, 0.0, local_9 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					ship = iShip.Cast( groupIter_0 );
					iAI.GiveEscortOrder( ship, groupIter_1, local_8, 0.0, local_9, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_8, 0.0, local_9, radius_ );
			}
		}
	}
}

SkirmishLine( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	bool local_2 = true;
	int local_3 = 0;
	float local_4;
	float constant = 0.0;
	int local_6;
	float local_7 = 0.0;
	float local_8 = 0.0;
	float local_9 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_4 = iUtilities.GetLargestShipRadius( group_ );
	local_4 = ( (local_4 * 2.0) + spacing_offset_ );
	local_9 = -local_4;
	local_8 = local_9;
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_2 == 1 )
			{
				if ( local_7 < 0.0 )
				{
					local_7 = -local_7;
				}
				
				local_7 = ( local_7 + local_4 );
				local_2 = false;
				local_3 = ( local_3 + 1 );
			}
			else
			{
				local_7 = -local_7;
				local_2 = true;
				local_3 = ( local_3 + 1 );
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_7, 0.0, local_8 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					ship = iShip.Cast( groupIter_0 );
					iAI.GiveEscortOrder( ship, groupIter_1, local_7, 0.0, local_8, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_7, 0.0, local_8, radius_ );
			}
			
			if ( local_3 == 2 )
			{
				local_3 = 0;
				
				if ( local_8 == 0.0 )
				{
					local_8 = local_9;
				}
				else
				{
					local_8 = 0.0;
				}
			}
		}
	}
}

Cross( hgroup ship_list_, float offset_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1 = 1;
	float local_2;
	float local_3;
	float local_4;
	float local_5;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( simCount == 1 )
	{
		return;
	}
	
	groupIter_1 = Group.NthSim( ship_list_, 0 );
	local_5 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + offset_ );
	
	do
	{
		local_2 = ( local_2 + 1.0 );
		groupIter_0 = Group.NthSim( ship_list_, local_1 );
		local_3 = ( local_2 * local_5 );
		local_4 = ( local_2 * local_5 );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, 0.0 );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, 0.0, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, 0.0, radius_ );
		}
		
		local_1 = ( local_1 + 1 );
		
		if ( local_1 < simCount )
		{
			groupIter_0 = Group.NthSim( ship_list_, local_1 );
			local_3 = ( local_2 * local_5 );
			local_4 = -( local_2 * local_5 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, 0.0 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, 0.0, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, 0.0, radius_ );
			}
			
			local_1 = ( local_1 + 1 );
			
			if ( local_1 < simCount )
			{
				groupIter_0 = Group.NthSim( ship_list_, local_1 );
				local_3 = -( local_2 * local_5 );
				local_4 = ( local_2 * local_5 );
				
				if ( first_time_ )
				{
					Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, 0.0 );
					
					if ( iShip.Cast( groupIter_0 ) )
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, 0.0, radius_ );
					}
				}
				else
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, 0.0, radius_ );
				}
				
				local_1 = ( local_1 + 1 );
				
				if ( local_1 < simCount )
				{
					groupIter_0 = Group.NthSim( ship_list_, local_1 );
					local_3 = -( local_2 * local_5 );
					local_4 = -( local_2 * local_5 );
					
					if ( first_time_ )
					{
						Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, 0.0 );
						
						if ( iShip.Cast( groupIter_0 ) )
						{
							iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, 0.0, radius_ );
						}
					}
					else
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, 0.0, radius_ );
					}
					
					local_1 = ( local_1 + 1 );
				}
			}
		}
	}
	while ( local_1 < simCount );
}

Loose( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
}

Impi( hgroup ship_list_, float offset_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1 = 1;
	float local_2;
	float local_3;
	float local_4 = 10.0;
	float local_5;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( simCount == 1 )
	{
		return;
	}
	
	groupIter_1 = Group.NthSim( ship_list_, 0 );
	local_5 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + offset_ );
	
	do
	{
		local_2 = ( local_2 + 1.0 );
		
		if ( local_2 < 4.0 )
		{
			local_4 = ( local_4 * local_2 );
		}
		else
		{
			local_4 = ( local_4 + local_4 );
		}
		
		groupIter_0 = Group.NthSim( ship_list_, local_1 );
		local_3 = ( (local_2 * local_5) + offset_ );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, 0.0, local_4 );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, 0.0, local_4, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, 0.0, local_4, radius_ );
		}
		
		local_1 = ( local_1 + 1 );
		
		if ( local_1 < simCount )
		{
			groupIter_0 = Group.NthSim( ship_list_, local_1 );
			local_3 = -( local_2 * local_5 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, 0.0, local_4 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, 0.0, local_4, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, 0.0, local_4, radius_ );
			}
			
			local_1 = ( local_1 + 1 );
		}
	}
	while ( local_1 < simCount );
}

Outrider( hgroup ship_list_, float offset_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1;
	int local_2;
	int local_3;
	float local_4;
	float local_5;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( simCount == 1 )
	{
		return;
	}
	
	groupIter_1 = Group.NthSim( ship_list_, 0 );
	local_1 = ( (simCount - 1) / 2 );
	local_5 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + offset_ );
	
	do
	{
		local_2 = ( local_2 + 1 );
		groupIter_0 = Group.NthSim( ship_list_, local_2 );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_4, 0.0, local_5 + 10.0 );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_4, 0.0, local_5 + 10.0, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_4, 0.0, local_5 + 10.0, radius_ );
		}
		
		local_4 = ( local_4 + local_5 );
		
		if ( (local_2 + 1) <= local_1 )
		{
			local_2 = ( local_2 + 1 );
			groupIter_0 = Group.NthSim( ship_list_, local_2 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, -local_4, 0.0, local_5 + 10.0 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, -local_4, 0.0, local_5 + 10.0, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), -local_4, 0.0, local_5 + 10.0, radius_ );
			}
		}
	}
	while ( local_2 < local_1 );
	
	local_4 = 0.0;
	
	do
	{
		local_2 = ( local_2 + 1 );
		groupIter_0 = Group.NthSim( ship_list_, local_2 );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_4, 0.0, -( local_5 + 10.0 ) );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_4, 0.0, -( local_5 + 10.0 ), radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_4, 0.0, -( local_5 + 10.0 ), radius_ );
		}
		
		local_4 = ( local_4 + local_5 );
		
		if ( (local_2 + 1) <= (simCount - 1) )
		{
			local_2 = ( local_2 + 1 );
			groupIter_0 = Group.NthSim( ship_list_, local_2 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, -local_4, 0.0, -( local_5 + 10.0 ) );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, -local_4, 0.0, -( local_5 + 10.0 ), radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), -local_4, 0.0, -( local_5 + 10.0 ), radius_ );
			}
		}
	}
	while ( local_2 < (simCount - 1) );
}

LineAstern( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	float local_2;
	int local_3;
	float local_4 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_2 = iUtilities.GetLargestShipRadius( group_ );
	local_2 = ( (local_2 * 2.0) + spacing_offset_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			local_4 = ( local_4 + local_2 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, 0.0, 0.0, local_4 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, 0.0, 0.0, local_4, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, 0.0, 0.0, local_4, radius_ );
			}
		}
	}
}

Box( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int local_1;
	int local_2;
	int ii;
	int local_4;
	int local_5 = 0;
	int local_6 = 0;
	float local_7;
	float local_8;
	float local_9 = 0.0;
	float local_10 = 0.0;
	float local_11 = 0.0;
	float local_12 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_12 = iUtilities.GetLargestShipRadius( group_ );
	local_12 = ( (local_12 * 2.0) + spacing_offset_ );
	local_7 = simCount;
	local_8 = Math.CubeRoot( local_7 );
	local_1 = local_8;
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
			local_5 = ( local_5 + 1 );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_5 == local_1 )
			{
				local_9 = 0.0;
				local_10 = ( local_10 - local_12 );
				local_5 = 1;
				local_6 = ( local_6 + 1 );
			}
			else
			{
				local_9 = ( local_9 + local_12 );
				local_5 = ( local_5 + 1 );
			}
			
			if ( local_6 == local_1 )
			{
				local_6 = 0;
				local_10 = 0.0;
				local_11 = ( local_11 - local_12 );
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_9, local_10, local_11 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_9, local_10, local_11, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_9, local_10, local_11, radius_ );
			}
		}
	}
}

Claw( hgroup ship_list_, float offset_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1 = 1;
	float local_2;
	float local_3;
	float local_4;
	float local_5 = 10.0;
	float local_6;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( simCount == 1 )
	{
		return;
	}
	
	groupIter_1 = Group.NthSim( ship_list_, 0 );
	local_6 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + offset_ );
	
	do
	{
		local_2 = ( local_2 + 1.0 );
		
		if ( local_2 < 4.0 )
		{
			local_5 = ( local_5 * local_2 );
		}
		else
		{
			local_5 = ( local_5 + local_5 );
		}
		
		groupIter_0 = Group.NthSim( ship_list_, local_1 );
		local_3 = ( (local_2 * local_6) + offset_ );
		local_4 = ( (local_2 * local_6) + offset_ );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, local_5 );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, local_5, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, local_5, radius_ );
		}
		
		local_1 = ( local_1 + 1 );
		
		if ( local_1 < simCount )
		{
			groupIter_0 = Group.NthSim( ship_list_, local_1 );
			local_3 = ( local_2 * local_6 );
			local_4 = -( local_2 * local_6 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, local_5 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, local_5, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, local_5, radius_ );
			}
			
			local_1 = ( local_1 + 1 );
			
			if ( local_1 < simCount )
			{
				groupIter_0 = Group.NthSim( ship_list_, local_1 );
				local_3 = -( local_2 * local_6 );
				local_4 = ( local_2 * local_6 );
				
				if ( first_time_ )
				{
					Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, local_5 );
					
					if ( iShip.Cast( groupIter_0 ) )
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, local_5, radius_ );
					}
				}
				else
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, local_5, radius_ );
				}
				
				local_1 = ( local_1 + 1 );
				
				if ( local_1 < simCount )
				{
					groupIter_0 = Group.NthSim( ship_list_, local_1 );
					local_3 = -( local_2 * local_6 );
					local_4 = -( local_2 * local_6 );
					
					if ( first_time_ )
					{
						Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3, local_4, local_5 );
						
						if ( iShip.Cast( groupIter_0 ) )
						{
							iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_3, local_4, local_5, radius_ );
						}
					}
					else
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), iShip.Cast( groupIter_1 ), local_3, local_4, local_5, radius_ );
					}
					
					local_1 = ( local_1 + 1 );
				}
			}
		}
	}
	while ( local_1 < simCount );
}

Wall( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int local_1;
	int local_2;
	int ii;
	int local_4;
	int local_5 = 0;
	float local_6;
	float local_7;
	float local_8 = 0.0;
	float local_9 = 0.0;
	float local_10 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_10 = iUtilities.GetLargestShipRadius( group_ );
	local_10 = ( (local_10 * 2.0) + spacing_offset_ );
	local_6 = simCount;
	local_7 = Math.Sqrt( local_6 );
	local_1 = local_7;
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
			local_5 = ( local_5 + 1 );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			
			if ( local_5 == local_1 )
			{
				local_8 = 0.0;
				local_9 = ( local_9 - local_10 );
				local_5 = 1;
			}
			else
			{
				local_8 = ( local_8 + local_10 );
				local_5 = ( local_5 + 1 );
			}
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_8, local_9, 0.0 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), groupIter_1, local_8, local_9, 0.0, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, local_8, local_9, 0.0, radius_ );
			}
		}
	}
}

RandomRectangle( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int local_0 = 0;
	int simCount;
	int random_0;
	float random_1;
	float random_2;
	float random_3;
	int local_6;
	hsim groupIter_0 = Group.NthSim( group_, 0 );
	hsim groupIter_1;
	
	simCount = Group.SimCount( group_ );
	radius_ = Object.FloatProperty( groupIter_0, "radius" );
	
	do
	{
		local_0 = ( local_0 + 1 );
		random_0 = Math.Random( 1.0, 3.0 );
		
		if ( random_0 == 1 )
		{
			random_1 = Math.Random( radius_, radius_ + spacing_offset_ );
		}
		else
		{
			random_1 = -Math.Random( radius_, radius_ + spacing_offset_ );
		}
		
		random_0 = Math.Random( 1.0, 3.0 );
		
		if ( random_0 == 1 )
		{
			random_2 = Math.Random( radius_, radius_ + spacing_offset_ );
		}
		else
		{
			random_2 = -Math.Random( radius_, radius_ + spacing_offset_ );
		}
		
		random_0 = Math.Random( 1.0, 3.0 );
		
		if ( random_0 == 1 )
		{
			random_3 = Math.Random( radius_, radius_ + spacing_offset_ );
		}
		else
		{
			random_3 = -Math.Random( radius_, radius_ + spacing_offset_ );
		}
		
		groupIter_1 = Group.NthSim( group_, local_0 );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_1, groupIter_0, random_1, random_2, random_3 );
			
			if ( iShip.Cast( groupIter_1 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_1 ), groupIter_0, random_1, random_2, random_3, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_1 ), iShip.Cast( groupIter_0 ), random_1, random_2, random_3, radius_ );
		}
	}
	while ( local_0 < (simCount - 1) );
}

RandomSphere( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int local_0 = 0;
	int simCount;
	int local_2;
	float radius_1;
	float local_4;
	float local_5;
	float local_6;
	float random;
	hsim groupIter_0 = Group.NthSim( group_, 0 );
	hsim groupIter_1;
	
	simCount = Group.SimCount( group_ );
	radius_1 = Object.FloatProperty( groupIter_0, "radius" );
	
	do
	{
		local_0 = ( local_0 + 1 );
		random = Math.Random( 0.0, 1.0 );
		random = ( (1.0 - (random * random)) * spacing_offset_ );
		groupIter_1 = Group.NthSim( group_, local_0 );
		
		if ( first_time_ )
		{
			Sim.PlaceNear( groupIter_1, groupIter_0, random );
			
			if ( iShip.Cast( groupIter_1 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_1 ), groupIter_0, local_4, local_5, local_6, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_1 ), iShip.Cast( groupIter_0 ), local_4, local_5, local_6, radius_ );
		}
	}
	while ( local_0 < (simCount - 1) );
}

Stack( hgroup group_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	float local_2;
	int local_3;
	float local_4 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_2 = iUtilities.GetLargestShipRadius( group_ );
	local_2 = ( (local_2 * 2.0) + spacing_offset_ );
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		if ( ii == 0 )
		{
			groupIter_1 = Group.NthSim( group_, ii );
		}
		else
		{
			groupIter_0 = Group.NthSim( group_, ii );
			local_4 = ( local_4 - local_2 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, 0.0, local_4, 0.0 );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					ship = iShip.Cast( groupIter_0 );
					iAI.GiveEscortOrder( ship, groupIter_1, 0.0, local_4, 0.0, radius_ );
				}
			}
			else
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, groupIter_1, 0.0, local_4, 0.0, radius_ );
			}
		}
	}
}

LockGroupsInFormation( hgroup lead_group_, hobject secondary_group_, float x_, float y_, float z_, float radius_, bool first_time_ )
{
	int local_0;
	int local_1;
	hsim groupLeader_0 = Group.Leader( lead_group_ );
	hsim groupLeader_1;
	int local_4;
	
	if ( Group.Cast( secondary_group_ ) )
	{
		groupLeader_1 = Group.Leader( Group.Cast( secondary_group_ ) );
	}
	else
	{
		groupLeader_1 = Sim.Cast( secondary_group_ );
	}
	
	if ( groupLeader_1 != false )
	{
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupLeader_1, groupLeader_0, x_, y_, z_ );
			
			if ( iShip.Cast( groupLeader_1 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupLeader_1 ), groupLeader_0, x_, y_, z_, radius_ );
			}
			
			return;
		}
		
		iAI.GiveEscortOrder( iShip.Cast( groupLeader_1 ), groupLeader_0, x_, y_, z_, radius_ );
	}
}

InFormationImpi( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1 = 0;
	float local_2;
	float local_3;
	float local_4 = 10.0;
	float local_5;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( Group.Cast( convoy_ ) )
	{
		groupIter_1 = Group.NthSim( Group.Cast( convoy_ ), ship_no_ );
	}
	else
	{
		groupIter_1 = Sim.Cast( convoy_ );
	}
	
	local_5 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + spacing_ );
	
	do
	{
		local_2 = ( local_2 + 1.0 );
		
		if ( local_2 < 4.0 )
		{
			local_4 = ( local_4 * local_2 );
		}
		else
		{
			local_4 = ( local_4 + local_4 );
		}
		
		groupIter_0 = Group.NthSim( ship_list_, local_1 );
		local_3 = ( (local_2 * local_5) + spacing_ );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_ );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_, radius_ );
		}
		
		local_1 = ( local_1 + 1 );
		
		if ( local_1 < simCount )
		{
			groupIter_0 = Group.NthSim( ship_list_, local_1 );
			local_3 = ( -( local_2 * local_5 ) - spacing_ );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_ );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, 0.0 + y_offset_, local_4 + z_offset_, radius_ );
			}
			
			local_1 = ( local_1 + 1 );
		}
	}
	while ( local_1 < simCount );
}

local_function_1( hgroup group_, hobject param_1_, int param_2_, float param_3_, float param_4_, float param_5_, float param_6_, float param_7_, bool param_8_, bool param_9_ )
{
	int simCount;
	int ii;
	bool local_2 = true;
	float local_3;
	int local_4;
	float local_5 = 0.0;
	float local_6 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( group_ );
	local_3 = iUtilities.GetLargestShipRadius( group_ );
	local_3 = ( (local_3 * 2.0) + param_6_ );
	
	if ( Group.Cast( param_1_ ) )
	{
		groupIter_1 = Group.NthSim( Group.Cast( param_1_ ), param_2_ );
	}
	else
	{
		groupIter_1 = iShip.Cast( param_1_ );
	}
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		groupIter_0 = Group.NthSim( group_, ii );
		
		if ( local_2 == 1 )
		{
			if ( local_5 < 0.0 )
			{
				local_5 = -local_5;
			}
			
			local_5 = ( local_5 + local_3 );
			local_2 = false;
			
			if ( param_9_ )
			{
				local_6 = ( local_6 - local_3 );
			}
			else
			{
				local_6 = ( local_6 + local_3 );
			}
		}
		else
		{
			local_5 = -local_5;
			local_2 = true;
		}
		
		if ( param_8_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_5 + param_3_, 0.0 + param_4_, local_6 + param_5_ );
			
			if ( iShip.Cast( Group.NthSim( group_, ii ) ) )
			{
				ship = iShip.Cast( Group.NthSim( group_, ii ) );
				iAI.GiveEscortOrder( ship, param_1_, local_5 + param_3_, 0.0 + param_4_, local_6 + param_5_, param_7_ );
			}
		}
		else
		{
			ship = iShip.Cast( Group.NthSim( group_, ii ) );
			iAI.GiveEscortOrder( ship, param_1_, local_5 + param_3_, 0.0 + param_4_, local_6 + param_5_, param_7_ );
		}
	}
}

InFormationV( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ )
{
	bool local_0 = false;
	
	local_function_1( ship_list_, convoy_, ship_no_, x_offset_, y_offset_, z_offset_, spacing_, radius_, first_time_, local_0 );
}

InFormationGoose( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_, float radius_, bool first_time_ )
{
	bool local_0 = true;
	
	local_function_1( ship_list_, convoy_, ship_no_, x_offset_, y_offset_, z_offset_, spacing_, radius_, first_time_, local_0 );
}

InFormationClaw( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float offset_, float radius_, bool first_time_ )
{
	int simCount = Group.SimCount( ship_list_ );
	int local_1 = 0;
	float local_2;
	float local_3;
	float local_4;
	float local_5 = 10.0;
	float local_6;
	hsim groupIter_0;
	hsim groupIter_1;
	
	if ( simCount == 1 )
	{
		return;
	}
	
	if ( Group.Cast( convoy_ ) )
	{
		groupIter_1 = Group.NthSim( Group.Cast( convoy_ ), ship_no_ );
	}
	else
	{
		groupIter_1 = iShip.Cast( convoy_ );
	}
	
	local_6 = ( (2.0 * iUtilities.GetLargestShipRadius( ship_list_ )) + offset_ );
	
	do
	{
		local_2 = ( local_2 + 1.0 );
		
		if ( local_2 < 4.0 )
		{
			local_5 = ( local_5 * local_2 );
		}
		else
		{
			local_5 = ( local_5 + local_5 );
		}
		
		groupIter_0 = Group.NthSim( ship_list_, local_1 );
		local_3 = ( (local_2 * local_6) + offset_ );
		local_4 = ( (local_2 * local_6) + offset_ );
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_ );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
			}
		}
		else
		{
			iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
		}
		
		local_1 = ( local_1 + 1 );
		
		if ( local_1 < simCount )
		{
			groupIter_0 = Group.NthSim( ship_list_, local_1 );
			local_3 = ( local_2 * local_6 );
			local_4 = -( local_2 * local_6 );
			
			if ( first_time_ )
			{
				Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_ );
				
				if ( iShip.Cast( groupIter_0 ) )
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
				}
			}
			else
			{
				iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
			}
			
			local_1 = ( local_1 + 1 );
			
			if ( local_1 < simCount )
			{
				groupIter_0 = Group.NthSim( ship_list_, local_1 );
				local_3 = -( local_2 * local_6 );
				local_4 = ( local_2 * local_6 );
				
				if ( first_time_ )
				{
					Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_ );
					
					if ( iShip.Cast( groupIter_0 ) )
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
					}
				}
				else
				{
					iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
				}
				
				local_1 = ( local_1 + 1 );
				
				if ( local_1 < simCount )
				{
					groupIter_0 = Group.NthSim( ship_list_, local_1 );
					local_3 = -( local_2 * local_6 );
					local_4 = -( local_2 * local_6 );
					
					if ( first_time_ )
					{
						Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_ );
						
						if ( iShip.Cast( groupIter_0 ) )
						{
							iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
						}
					}
					else
					{
						iAI.GiveEscortOrder( iShip.Cast( groupIter_0 ), convoy_, local_3 + x_offset_, local_4 + y_offset_, local_5 + z_offset_, radius_ );
					}
					
					local_1 = ( local_1 + 1 );
				}
			}
		}
	}
	while ( local_1 < simCount );
}

InFormationSkirmishLine( hgroup ship_list_, hobject convoy_, int ship_no_, float x_offset_, float y_offset_, float z_offset_, float spacing_offset_, float radius_, bool first_time_ )
{
	int simCount;
	int ii;
	bool local_2 = true;
	int local_3 = 0;
	float local_4;
	float constant = 0.0;
	int local_6;
	float local_7 = 0.0;
	float local_8 = 0.0;
	float local_9 = 0.0;
	hsim groupIter_0;
	hsim groupIter_1;
	hship ship;
	
	simCount = Group.SimCount( ship_list_ );
	local_4 = iUtilities.GetLargestShipRadius( ship_list_ );
	local_4 = ( (local_4 * 2.0) + spacing_offset_ );
	local_9 = -local_4;
	local_8 = local_9;
	
	if ( Group.Cast( convoy_ ) )
	{
		groupIter_1 = Group.NthSim( Group.Cast( convoy_ ), ship_no_ );
	}
	else
	{
		groupIter_1 = Sim.Cast( convoy_ );
	}
	
	for ( ii = 0; ii < simCount; ++ii )
	{
		groupIter_0 = Group.NthSim( ship_list_, ii );
		
		if ( local_2 == 1 )
		{
			if ( local_7 < 0.0 )
			{
				local_7 = -local_7;
			}
			
			local_7 = ( local_7 + local_4 );
			local_2 = false;
			local_3 = ( local_3 + 1 );
		}
		else
		{
			local_7 = -local_7;
			local_2 = true;
			local_3 = ( local_3 + 1 );
		}
		
		if ( first_time_ )
		{
			Sim.PlaceRelativeTo( groupIter_0, groupIter_1, local_7 + x_offset_, 0.0 + y_offset_, local_8 + z_offset_ );
			
			if ( iShip.Cast( groupIter_0 ) )
			{
				ship = iShip.Cast( groupIter_0 );
				iAI.GiveEscortOrder( ship, convoy_, local_7 + x_offset_, 0.0 + y_offset_, local_8 + z_offset_, radius_ );
			}
		}
		else
		{
			ship = iShip.Cast( Group.NthSim( ship_list_, ii ) );
			iAI.GiveEscortOrder( ship, convoy_, local_7 + x_offset_, 0.0 + y_offset_, local_8 + z_offset_, radius_ );
		}
		
		if ( local_3 == 2 )
		{
			local_3 = 0;
			
			if ( local_8 == 0.0 )
			{
				local_8 = local_9;
			}
			else
			{
				local_8 = 0.0;
			}
		}
	}
}

